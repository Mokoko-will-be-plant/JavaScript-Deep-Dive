# 전역 변수의 문제점

- 호이스팅 : 변수 선언이 스코프이 선두로 끌어 올려진 것 처럼 동작하는것.<br>
  스코프 단위로 동작한다.

- 전역객체 : 코드 실행 전 JS엔진에 의해 가장 먼저 생성된 객체<br>
  ex) 브라우저의 window, node.js의 global 객체<br>
  es11에서 globalThis로 통일됨

var로 선언한 전역변수는 브라우저 환경의 전역객체인 window 객체의 프로퍼티가 된다.<br>
=> 전역객체의 생명주기와 일치한다.

## 문제점

1. 암묵적 결합<br>
   : 전역 변수는 어디서든지 참조/할당이 가능하다.<br>
   이는 모든 코드가 전역변수를 변경할 수 있다는 뜻.<br>
   => 가독성을 저하시키고, 의도치 않은 상태 변경이 발생할 수 있다.

2. 긴 생명주기<br>
   : 전역 변수는 생명주기가 길기 때문에 메모리 리소드도 오랜 기간 사용한다.<br> 생명주기가 긴 전역변수는 변수명이 중복될 수 있으며 이는 재할당이 일어날 수 있다.<br>
   지역변수는 전역변수보다 생명주기가 짧으며 이는 전역변수보다 상태변경에 의한 오류가 발생할 확률이 작다.

3. 스코프 체인상에서 종점에 존재<br>
   : 변수를 검색할 때 가장 마지막에 검색된다.<br>
   = 검색 속도가 가장 느리다는 뜻!

4. 네임스페이스 오염<br>
   : 파일이 분리되어 있다 해도 하나의 전역스코프를 공유하기 때문에 다른 파일내에서 동일한 이름의 전역변수나 함수가 있을경우 예상치 못한 결과를 발생시킬 수 있다.

변수의 스코프는 좁을수록 좋다!!

<br>

### 전역 변수를 대체할 방법

1. 즉시 실행 함수
   함수 정의와 동시에 호출되는 즉시 실행함수는 단 한번만 호출됨.
   => 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```javascript
(function () {
  var foo = 10; // 즉시 실행 함수의 지역변수
})();
console.log(foo); // error : foo is not defined
```

2. 네임스페이스 객체
   전역에 네임스페이스 역할을 담당할 객체를 생성하고 변수를 프로퍼티로 추가하는 방법.

```javascript
var MYAPP = {};

MYAPP.name = 'Jeong';
console.log(MYAPP.name); // Jeong
```

=> 그닥 유용하지 않음

3. 모듈 패턴
   클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는것.

클로저를 기반으로 동작한다.

전역변수의 억제 및 캡슐화 구현 가능

```javascript
var Counter = (function () {
  // private 변수
  var num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

// private 변수는 외부로 노출되지 않음
console.log(Counter.num); // undefind

console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```

위의 즉시 실행 함수는 객체를 반환함

4. es6 모듈

es6모듈은 파일 자체의 독자적인 모듈 스코프를 제공하기 때문에 더는 전역변수를 사용할 수 없다.<br>
모듈 내에서 var로 선언한 변수는 전역 변수가 아니다.<br>
script 태그에 `type='module'` 을 추가하면 js파일이 모듈로 동작한다.<br>
모듈의 확장자는 `.mjs`를 권장한다.
