# 25장 클래스
### ES6에서 클래스는 함수이며 기존 프로토 타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼수도 있다. 하지만 새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다.

<br>

> ### 클래스와 생성자 함수의 차이점
- ### 클래스
 1. `new 없이 호출 시 에러` 발생한다.
 2. 클래스는 `상속`을 지원하는 `extends`와 `super`를 지원, 
 3. 클래스는 호이스팅이 `발생하지 않는 것처럼 동작`, 하지만 `호이스팅이 발생하긴 함`!
 4. 클래스 내의 모든 코드는 암묵적으로 `strict mode`가 지정되어 해제 불가
 5. 클래스의 `constructor`, `프로토타입 메서드`, `정적메서드`는 모두 프로퍼티 어트리뷰트의 값이 false, 즉 `열거되지 않음`

- ### 생성자 함수
 1. `생성자는 new가 없으면 일반 함수`로 취급
 2. 상속을 지원하는 `extends`와 `super`를 `지원하지 않음`
 3. `함수 선언문`으로 선언 시 `함수 호이스팅`, `함수 표현식`으로 정의시 `변수 호이스팅`이 발생
 4. 생성자는 암묵적으로 `strict mode`가 지정되지 않음

> ### 클래스의 특징
### 클래스는 1급 객체이고 다음과 같은 특징이 있다.
- 무명의 리터럴로 생성가능, 즉 런타임이 가능
- 변수나 자료구조에 저장 가능
- 함수의 매개변수에 전달 가능
- 함수의 반환 값으로 사용 가능

<br>

#### 클래스 몸체에는 constructor(생성자), 프로토타입 메서드, 정적 메서드 세 가지가 있다.

<br>

> ## 클래스 호이스팅
- 클래스는 함수로 평가된다
- 클래스 선언문도 변수선언, 함수정의와 마찬가지로 호이스팅이 발생, 단 let, const로 선언한 변수처럼 호이스팅이 이루어짐

<br>

> ## 메서드
- ### constructor
1. 인스턴스를 생성 및 초기화 할때 사용한다.
2. 한개의 클래스에는 constructor가 한개만 존재 가능(중복 선언 불가능)
3. 암묵적으로 this, 즉 인스턴스를 반환함 -> 명시적으로 반환하면 명시한 객체가 반환 됌
- ### 프로토타입
- ### 정적

<br>

> ## 정적 메서드와 프로토 타입 메서드의 차이
- 각자 서로 속해있는 프로토타입 체인이 다르다.
- 정적 메서드는 클래스로 호출, 프로토타입 메서드는 인스턴스로 호출
- 정적 메서드는 인스턴스 프로퍼티르 참조할 수 없지만, 프로토타입 메서드는 가능

<br>

> ## 클래스에서 정의한 메서드의 특징
1. function 키워드 생략한 축약 표현 가능
2. 객체 리터럴과 다르게 클래스에 메서드 정의시 콤마 필요 없음
3. 암묵적으로 strict mode
4. 열거 불가능
5. 내부 [[constructor]]를 갖지 않는 non-constructor다. 따라서 new와 함께 부를수 없음

<br>

> ## Private 필드 정의 제안(#)
- 클래스는 외부에서 언제나 참조할 수 있다, 즉 언제나 public이다.
- 하지만 private 필드로 정의하면 클래스 내부에서만 참조할 수 있다.

<br>

> ## 수퍼클래스와 서브 클래스
- extends(상속)를 사용하여 클래스를 확장시키면 상속 받은 클래스는 서브 클래스이고, 서브클래스에 상속된 클래스를 수퍼클래스라 한다

<br>

> ## super 키워드
- 함수처럼 호출도 할 수 있고, this처럼 식별자를 참조할수도 있다.
- super를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.